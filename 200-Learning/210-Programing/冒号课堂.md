---
title: "冒号课堂"
description: ""
pubDate: "2023-07-19 12:12"
heroImage: "https://images.unsplash.com/photo-1509062522246-3755977927d7?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1200&q=80"
date created: "2023-07-19 12:12"
date modified: "2023-07-19"
tags:
    - notes
    - Programming
---

> Computers are useless. They can only give you answers.
> — <cite>Pablo Picasso</cite>

## TOC


## 重要范式

> [!info] 🍭 
> 从理论上而言，完全可以有非命令式的机器语言存在，前提是计算机采用了特殊的硬件实现，比如非冯·诺伊曼结构的数据流机 (`dataflow machine`)和归约机(`reduction machine`)。但这类计算机并未流行于市，相应的机器语言自然罕见了

### 编程范式

#### 命令式编程

> 命令式编程(`imperative programming`)。用命令式编写的 程序由命令序列组成，即一系列祈使句:‘先做这，再做那’，强调‘怎么 做’。更学术点说，命令式编程是电脑——准确地讲，是冯·诺伊曼机 (`von Neumann machine`)——运行机制的抽象，即依序从内存中获取指 令和数据，然后去执行。从范式的角度看，其世界观是:程序是由若 干行动指令组成的有序列表。其方法论是:用变量来存储数据，用语 句来执行指令。


命令式编程是行动导向的，因而算法是显性而结果是隐性的；声明式编程是目标驱动的，因而目标是显性而算法是隐性的

#### 结构化编程
> 结构化编程(`structured programming`或简称SP)，它是在过程 式编程的基础上发展起来的。其本质是一种编程原则，提倡代码应具有 清晰的逻辑结构，以保证程序易于读写、测试、维护和优化。

典型语言：`Pascal`

#### 声明式编程

主要包括函数式编程和逻辑式编程。

> [!info]
> 函数式编程：将计算描述为数学函数的求值 逻辑式编程：通过提供一系列事实和规则来推导和论证结论

函数式语言典型语言：Lisp、Haskll、Scheme
逻辑式语言典型语言：Prolog

使用不同编程范式实现阶乘运算

```c
int factorial(int n) {
	int f = 1;
	for (; n > 1; --n) f *= n;

	return f;
}
```
```lisp
defun factorial(n) (
	if (= n 0) 1
	(* n (factorial(- n 1)))
)
```
```prolog
factorial(0, 1).
factorial(N, F) :- M is N-1, factorial(M, Fm), F is N * Fm.
```

不同：C明确给出了阶乘的迭代算法，而Lisp仅描述了阶乘的递归定义，Prolog则陈述了两个关于阶乘的断言

>[!summary]
>声明式编程让我们重回数学思维； 函数式编程类似代数中的表达式变换和计算； 逻辑式编程则类似数理推理逻辑，其中的变量也如数学中一样，是抽象符号而非内存地址。因此，没有赋值运算，不会产生变量被改写的副作用（side effect），也不存在内存分配和释放的问题。

迭代和递归的区别：

1. 迭代比递归更符合命令式的思维模式，因前者贴近机器语言而后者贴近数学语言
2. 除了尾递归（`tail recursion`）外，一般递归比迭代开销大
3. 声明式语言提倡递归而不支持迭代
    1. 就语法而言，它不允许迭代中的循环变量
    2. 就视角而言，迭代着眼于微观过程而递归着眼于宏观过程

![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230719123214.png)

|范式|程序|输入|输出|程序设计|程序运行|
|---|---|---|---|---|---|
|命令式|自动机|初始状态|最终状态|设计指令|命令执行|
|函数式|数学函数|自变量|因变量|设计函数|表达式转换|
|逻辑式|逻辑证明|题设|结论|设计命题|逻辑推理|

### 对象范式（OOP）

函数是被动的实体，对象是主动的实体
过程式程序的世界是君主制的；OO程序是民主制的
封装使得公民拥有个体身份；继承使得公民拥有家庭身份；多态使得公民拥有社会身份
函数式、命令式、逻辑式互相平行，而OOP与他们正交
与其说OOP更具重用性，倒不如说更具易用性

>[!tip]
>对一个没有独立思考习惯的人来讲，与其说他认同一个理论，不如说他认同该理论倡导者的权威，而在他仰视权威的同时，也把自己的思想交托给了权威。

### 并发范式（合作与竞争）

并发式编程以进程为导向，以任务为中心将系统模块化
并发式编程以资源共享与竞争为主线
程序设计将围绕进程的划分与调度、进程之间的通信与同步来展开

## 常用范式

### 泛型范式 Generic Programming

泛型编程是算法导向的，即以算法为起点和中心点，逐渐将所涉及的概念内涵模糊化、外延扩大化，将所涉及的运算抽象化、一般化，从而扩展算法的适用范围

STL有3要素: 算法、容器和和迭代器。算法是一系列可行的步骤；容器是数据的集合，是抽象化的数组；迭代器是算法与容器之间的接口，是抽象化的指针。算法串联数据，数据实化算法。

泛型编程不仅能泛化算法中涉及的概念(数据类型)，还能泛 化行为(函数、方法、运算)。

对指定集合中满足指定条件的元素进行指定处理。

通过模板，泛化了容器———可以是数组、列表、集合、映射、队列、栈、字符串等等；泛化了元素——可以是任何数据类型，泛化了处理方法和限定条件——可以是任何函数。

这里的处理方法和限定条件不限于函数，还可以是函子（`functor`）——自带状态的函数对象；另外，迭代器也被泛化了——可以从前往后移动，，可以来回移动，可以随机移动，可以按任意预定义的规律移动。

泛型编程是算法导向的，以算法为中心，逐渐将其所涉及的概 念内涵模糊化、外延扩大化，并将其所涉及的运算抽象化、一般化，从 而提高算法的可重用性。

### 元编程 Meta Programming

元编程：关于程序的程序，或者说是编写、操纵程序的程序

元程序将程序作为数据来对待，能自我发现、自我赋权和自我升级，有着其他程序所不具备的自觉性、自适应性和智能性，可以说是一种最高级的程序。
```c++
// 元编程
template <int N>
struct factorial {
	enum { value: N * factorial<N - 1>::value };
};

template <> // 特化（speicialization）
struct factorial<0> { // 递归中止
	enum { value = 1 };
};

void main() {
	// 以下等价于 cout << 120 << end1;
	cout << factorial<5>::value << end1;
}
```

`Lex` `Yacc` `ANTLR`

编译器本身就是元编程的典型范例———把高级语言转化为汇编语言或机器语言的程序，不就是能写程序的程序吗？

>[!info]
>🖥️ 语言导向式编程（Language-Oriented Programming，简称`LOP`）

产生式编程与静态元编程都能自动生成源代码。产生式编程强调代码的生成，元编程强调生成代码的可执行性。此外，动态元编程并不生成源代码，但能在运行期间修改程序。

### 切面范式（AOP）

从宏观角度看，太阳底下没有新鲜事——AOP无非是SoC原理和DRY原则的一种应用； 从微观角度看，太阳每天都是新的——AOP虽自OOP的土壤中长出，却脱离藩篱自成一体。

OOP 只能沿着继承树的纵向方向重用，AOP就是在管道上钻一些孔，在每个孔中注入新的代码流

>[!quote]
>SoC：Separation of Concerns。即关注点分离

抽象与分解的原则：单一化、正交化。每个模块职责明确专一；模块之间相互独立，即高内聚低耦合（high cohesion & low coupling）。此原则相当普适，是分析复杂事物的一种基本方法，在数学和物理中应用尤为广泛，如质因式分解、正交分解、谱分解等等。

## OOP

>A script is what you give the actors, a program is what you give the audience 
>脚本是给演员看的，节目是给观众看的。

>[!quote]
>理想的架构师应当如文学大师，既有恢弘大气的 构思，又有细腻深刻的笔法;应当如统军大帅，既有运筹帷幄的韬略， 又有冲锋陷阵的武功。那些在语言与低级之间、设计与高级之间毫不犹 豫地划等号的人，多半高不成低不就，既不懂语言，也不懂设计。

RAII（Resource Acquisition Is Initialization）: 资源获取即初始化，准确称为RRIF（Resource Release Is Finalization，资源释放即终结化） 将资源的取放于某一生命周期绑定，初始化对象时获取资源，终结化时释放资源，用户不再直接管理资源，只需控制相应的对象即可。

DTO（Data Transfer Object或DTO）：数据传输对象，不含业务逻辑，仅作为简单数据容器，实际上也属于具体数据类型

> Programming to an interface, not an Implementation
> 通过接口而非实现来编程


抽象：将一类模型最本质最不易变化的部分提炼出来 
封装：将信息隐藏，即是将非本质、容易变化的部分隐藏起来，从而将一个类划分为阴阳两面

OCP（Open/Close Principle）: 开闭原则，对扩展开放，对修改封闭

