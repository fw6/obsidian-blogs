---
title: "浏览器实现原理"
description: ""
pubDate: "2023-08-01 16:15"
heroImage: "https://images.unsplash.com/photo-1690381529568-6bb94ed73469?crop=entropy&cs=srgb&fm=jpg&ixid=M3wzNjM5Nzd8MHwxfHJhbmRvbXx8fHx8fHx8fDE2OTA4Nzc3MzB8&ixlib=rb-4.0.3&q=85"
date created: "2023-08-01 16:15"
date modified: "2023-08-01"
draft: true
tags:
    - writings
    - FE
---

浏览器从URL到网页的过程：
1. 浏览器使用HTTP协议或者HTTPS协议，向服务器请求页面
2. 把请求回来的HTML代码经过解析，构建成DOM树
3. 计算DOM树上的CSS属性
4. 最后根据CSS属性对元素逐个进行渲染，得到内存中的位图
5. 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度
6. 合成之后，再会知道界面上

从HTTP请求回来之后，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。
从HTTP请求回来，就构成了流式的数据，后续的DOM树构建、CSS计算、渲染、合成、绘制，都是尽可能地处理前一步的产出：即不等到上一步骤完全结束，就开始处理上一步的输出，这样在浏览网页时，才会看到逐步出现的画面。

## HTTP协议


浏览器要做的事就是根据URL把数据取出来，取回数据使用的是HTTP协议，实际上这个过程之前还有个DNS查询。

HTTP标准由IETF组织制定，跟它相关的标准主要有两份：
- [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc2616) 
- [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc7234)

HTTP协议是基于TCP协议出现的，对TCP协议来说，TCP协议是一条双向的通讯通道，HTTP在TCP基础上，规定了Requset-Response的模式。这个模式决定了必定是由浏览器端率先发起的。

大部分情况下，浏览器的实现者只需要用一个TCP库，甚至一个现成的HTTP库就能搞定浏览器的网络通讯部分。HTTP是纯粹的文本协议，它是规定了使用TCP协议来传输文本格式的一个应用层协议。

下面我们使用纯粹的TCP客户端手动实现HTTP

首先运行telnet，并连接到`baidu.com`主机，在命令行输入如下内容
```sh
telnet baidu.com 80
```

 ![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230801175451.png)


这个时候，TCP连接已经简历，输入如下字符作为请求：
```
GET / HTTP/1.1
Host: baidu.com
```
按下两次回车，可收到服务端请求：
```
HTTP/1.1 200 OK
Date: Tue, 01 Aug 2023 09:47:39 GMT
Server: Apache
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
ETag: "51-47cf7e6ee8400"
Accept-Ranges: bytes
Content-Length: 81
Cache-Control: max-age=86400
Expires: Wed, 02 Aug 2023 09:47:39 GMT
Connection: Keep-Alive
Content-Type: text/html

<html>
<meta http-equiv="refresh" content="0;url=http://www.baidu.com/">
</html>
```

这就是一次完整的HTTP请求过程了，可以看到在TCP通道中传输的，完全是文本。

在请求部分，第一行被称作request line，它分为3部分：HTTP Method、请求路径、请求的协议和版本。

在响应部分，第一行被称为response line，也分为3部分：协议和版本、状态码和状态文本。
紧跟在request line或response line之后的，是请求头/响应头，这些头由若干行组成，每行是用冒号分割的名称和值。

在头之后，以一个空行（两个换行符）为分割，是请求体/响应体，请求体可能包含文件或者表单数据，响应体则是HTML代码。

### HTTP Method

首先看request line里面的方法。这里的方法与编程中的方法意义类似，表示此次HTTP请求希望执行的操作类型。方法有以下几种定义：
- GET
- POST
- HEAD
- PUT
- DELETE
- CONNECT
- OPTIONS
- TRACE

浏览器通过地址栏访问都是GET方法，表单提交产生POST方法。
HEAD与GET类似，只返回响应头，多数由JavaScript发起。
PUT和DELETE分别表示添加资源和删除资源，但这只是语义上的约束。
CONNECT多用于HTTPS和WebSocket
OPTIONS和TRACE一般用于调试，多数线上服务都不支持。

### HTTP Status code & Status text

常见的HTTP状态码有以下几种：
- 1xx：临时回应，表示客户端请继续
- 2xx：请求成功
- 3xx： 表示请求目标有变化，希望客户端进一步处理
    - 301 & 302: 永久性或临时性跳转
    - 304: 客户端缓存没更新
- 4xx：客户端请求错误
    - 403: 无权限
    - 404: 请求页面不存在
- 5xx：服务端请求错误
    - 500: 服务端错误
    - 503: 服务端暂时性错误，可重试

对前端而言，1xx系列的状态码非常陌生，原因是1xx的状态被浏览器HTTP库直接处理掉了，不会让上层应用知晓。
2xx系列最熟悉的是200，这通常是网页请求成功的标志。
3xx系列比较复杂，301和302两个状态表示当前资源已被转移，不过一个是永久转移一个是临时转移。实际上301更近似报错，表示客户端下次别来了。
304产生的前提是：客户端本地已经有缓存的版本了，并且在Request中告诉了服务器，当服务器通过事件或tag发现没有更新的时候，就会返回不含body的304状态。

### HTTP Head

HTTP头可以看成一个键值对。原则上HTTP头也是一种数据，我们可以自由定义HTTP头和值。在HTTP标准中定义了完整的请求、响应头。

先来看看Request Header。
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230801182023.png)
接下来看下Response Header：
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230801182111.png)

上方仅仅列出了常用的HTTP头，完整列表可在rfc2616中找到。

### HTTP Request Body

HTTP请求的Body主要用于提交表单的场景。实际上HTTP请求的body是比较自由的，只要浏览器端发送的Body服务端认可就可以。一些常见的body格式：
- application/json
- application/x-www-form-urlencoded
- multipart/form-data
- text/xml


### HTTPS

在HTTP协议的基础上，HTTPS和HTTP2规定了更复杂的内容，但是它基本保持了HTTP的设计思想，即：Request-Response模式。

HTTPS有两个作用，一是确定请求的目标服务器身份，二是保证传输的数据不会被网络中间节点窃听或篡改。

HTTPS相关标准链接：[RFC 2818 - HTTP Over TLS](https://datatracker.ietf.org/doc/html/rfc2818)
HTTPS使用加密通道传输HTTP的内容，但是HTTP首先与服务器建立一条TLS加密通道。TLS构建于TCP协议之上，它实际上是对传输内容作了一次加密，所以从传输内容上看，HTTPS和HTTP没有任何区别。

### HTTP2

HTTP2是对HTTP1.1的升级，相关标准参考：[RFC 7540 - Hypertext Transfer Protocol Version 2 (HTTP/2)](https://datatracker.ietf.org/doc/html/rfc7540)

HTTP2.0最大的改进有2点，一是支持服务端推送，二是支持TCP连接复用。

服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存中。可以避免客户端请求顺序带来的并行度不高导致的性能问题。
TCP连接复用，则使用同一个TCP连接来传输多个HTTP请求，避免了TCP连接建立时的3次握手开销，和初建TCP连接时传输窗口小的问题。

## 构建DOM树

通过HTTP请求返回了网页的HTML内容，接下来介绍如何解析HTML代码，DOM树又如何构建。

HTML的结构并不算太复杂，日常开发需要的“词”（编译原理中的token，表示最小有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA节点几种。
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230801190213.png)

浏览器从HTTP协议收到的字符流读取字符。每输入一个字符，都要做一个决策，判断当前节点类型与操作，浏览器工程师常用状态机实现将字符流解析为词。

![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230801190432.png)
[HTML官方文档](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)规定了80多个状态，用状态机做词法分析，其实就是把每个词的特征字符逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成连通图结构。

接下来要把这些简单的词构建为DOM树，这个过程用栈来实现：
```js
function HTMLSyntaticalParser(){
    var stack = [new HTMLDocument];
    this.receiveInput = function(token) {
        //……
    }
    this.getOutput = function(){
        return stack[0];
    }
}
```

receiveInput负责接受词法部分产生的词，在接受的同时开始构建DOM树，当接收完所有输入，栈顶就是最后的根节点了，也就是DOM树的产出。在符合标准的浏览器中，不一样的HTML节点对应了不同的Node的子类。

大致流程如下：
- 栈顶元素就是当前节点
- 遇到属性，就添加到当前节点
- 遇到文本节点，如果当前是文本节点，则与文本节点合并，否则入栈作为当前节点的子节点
- 遇到注释节点，作为当前节点的子节点
- 遇到tag start就入栈一个节点，当前节点还是这个节点的父节点
- 遇到tag end就出栈一个节点（还可以检查是否匹配）
