---
title: "随便整理的前端面试常考点"
description: ""
pubDate: "2023-08-02 09:22"
heroImage: "https://images.unsplash.com/photo-1666278749123-6cc58220fda9?crop=entropy&cs=srgb&fm=jpg&ixid=M3wzNjM5Nzd8MHwxfHJhbmRvbXx8fHx8fHx8fDE2OTA5MzkzNTJ8&ixlib=rb-4.0.3&q=85"
date created: "2023-08-02 09:22"
date modified: "2023-08-02"
draft: true
tags:
    - writings
---

## TOC


## 浏览器

### DOM树怎么生成的?

一旦浏览器收到第一块数据，它就开始解析收到的信息。“解析”是浏览器将通过网络接收到的数据转换为DOM、CSSOM的步骤，通过渲染器把DOM和CSSOM在屏幕上绘制成页面。

:::info
即使请求的页面HTML超过了14KB，浏览器也将开始解析尝试根据其数据进行渲染。这就是为什么在前14KB中包含浏览器开始渲染页面的所有内容，或至少包含页面模板（第一次渲染所需的CSS和HTML），这对Web性能优化很重要。
:::

渲染DOM树分为5个阶段：
1. 处理HTML标记并构造DOM树。当遇到CSS文件、非阻塞资源（如图片）时解析继续进行，但对于没有`defer`或`async`属性的`<script>`标签时，浏览器会阻塞渲染并停止HTML的解析（虽然浏览器的预加载扫描器会加速该过程）。等待获取CSS不会阻塞HTML解析但会阻塞JavaScript！
2. 处理CSS并构建CSSOM树。CSSOM包含来自用户代理样式表的样式。在此同时，也会有JavaScript编译、构建辅助功能树等过程
3. 将DOM和CSSOM组合为一个Render树。Render树将所有相关样式匹配到DOM树的每个可见节点，并根据CSS级联确定每个节点的计算样式。
4. 在渲染树上运行布局以计算每个节点的几何体。第一次确定节点的大小和位置称为布局，随后对节点和大小的重新计算称为回流。
5. 最后一步将各个节点绘制到屏幕上。绘制可以将布局树上的元素分解为多层，将内容提升到GPU上的层可以提高绘制和重绘性能。当文档中各个不同部分以不同的层绘制相互重叠时，就必须进行合成，以确保按照正确的顺序绘制到屏幕上。

:::note
使用Chrome开发工具进行性能分析分析：
1. Chrome DevTools - more tools - Layers
2. Chrome DevTools - more tools - Rendering
3. Chrome DevTools - more tools - Animations
4. Chrome DevTools - Performance
:::

### script标签中`async`和`defer`属性的区别？

带`async`属性的脚本：
- 对于普通脚本则会并行请求，并加快解析和执行；
- 对于模块脚本，那么脚本及其所有依赖都会在延迟队列中执行，确保它们会被并行请求并尽快解析和执行。

带`defer`属性的脚本：
- 对模块脚本不生效（默认`defer`）
- 对缺少`src`属性的脚本不生效
- 表示在文档解析后，但在触发`DOMContentLoaded`之前执行
- 阻塞`DOMContentLoaded`事件触发，直到脚本完成加载并执行
- 按照文档出现顺序执行

### 讲下浏览器渲染时的合成层？

在每个DOM树节点都会对应一个LayoutObject，当它们的LayoutObject处于相同的坐标空间时，就会形成一个RenderLayers，也就是渲染层。

RenderLayers保证页面以正确的顺序合成，这时候就出现了层的合成（composite），从而正确处理透明元素与重叠元素的显示。

在Chrome中有两种不同的层类型：
- RenderLayer渲染层，负责对应的DOM子树
- GraphicsLayer图形层，负责对应的RenderLayer子树

在RenderLayer下有RenderObject，其保持了树结构并通过向绘图上下文（GraphicsContext）发出绘制调用来绘制Nodes。
每个GraphicsLayer下都有一个GraphicsContext，其用于负责输出该层的位图，位图储存在共享内存中作为纹理上传到GPU中，最后由GPU将多个位图合成，然后draw到屏幕上

:::note
GraphicsContext绘图上下文的责任就是向屏幕进行像素绘制（先把像素级别数据存在位图，然后再显示到显示器），在Chrome里绘图上下文包含了Skia的调用
:::

某些特殊的渲染层会被认为是合成层（Composition Layer），合成层拥有单独的GraphicsContext，而其他非合成层的渲染层，则和第一个拥有GraphicsContext父层共用一个。

影响composite的因素：
- Transform 3D：translate3D，translateZ等
- video、canvas、iframe等元素
- 通过`Element.animate`实现的opacity动画转换
- 通过CSS 动画实现的opacity动画转换
- postion: fixed;
- will-change
- filter
- 有合成层的后代元素同时本身overflow不为visible
- ...

### 回流和重绘的区别？

- Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。
- Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。


### 浏览器缓存？

缓存分为4种，当一次查找且都没命中时，才会请求网络：
- Service Worker + Cache Storage
- Memory Cache。内存使用率比较高的文件。关闭Tab页面就释放
- Disk Cache。 比较大的 JS、CSS 文件会直接被丢进磁盘。
- Push Cache + HTTP2。只在会话存在

通过`HTTP Header`设置缓存策略：
1. 强缓存
    使用强缓存不会发送HTTP请求，直接从缓存中拿数据，状态码为200，size显示为`from disk cache`或`from memory cache`。
    强缓存可以通过设置两种 HTTP Header 实现：`Expires` （服务器事件和浏览器事件可能不一致）和 `Cache-Control`。
2. 协商缓存。
    强缓存失效就进入协商缓存。
    浏览器在请求头中携带缓存标识，服务器根据缓存标识决定是否使用缓存，协商缓存生效则返回 304 和 Not Modified，失效则返回 200 和请求结果。
    协商缓存可以可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag`。

:::warning
**如果什么缓存策略都没设置**：浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。
:::

## JavaScript

### 说说你知道的JavaScript解释器？

JIT(Just-in-time) compilation engines：
- v8。Google Chrome
- Chakra。Edge(Internet Explore)
- Spider Monkey。Mozilla FireFox
- JavaScript Core Webkit。Safari
- Hermes。Meta React Native

Runtime interpreter engines：
- QuickJS
- Boa。Written in Rust
- Rhino。Mozilla

### 聊聊你了解的V8垃圾回收

#### 调用栈的垃圾回收

有一个记录当前执行状态的指针(称为 ESP)指向调用栈中的函数执行上下文。当函数执行完成之后，就需要销毁函数的执行上下文了，这时候，ESP 就帮上忙了，JavaScript 会将 ESP 下移到后面的函数执行上下文，这个下移的过程就是销毁当前函数执行上下文的过程。

#### 堆中的垃圾回收

与栈中的垃圾回收不同的是，栈中无效的内存会被直接覆盖掉，而堆中的垃圾回收需要使用 JavaScript 中的垃圾回收器。

垃圾回收一般分为下面的几个步骤：
1. 通过 GC Root 标记空间中的**活动对象**和**非活动对象**
    目前 V8 采用 可访问性(reachablility)算法来判断堆中的对象是否为活动对象。这个算法其实就将一些 GC Root 作为初始存活对象的集合，从 GC Root 对象触发，遍历 GC Root 中的所有对象。
    1. 能够通过 GC Root 遍历到的对象会被认为**是可访问的**，我们将其标记为活动对象，必须保留
    2. 如果一个对象无法通过 GC Root 遍历到，那么就认为这个对象是**不可访问的**，可能需要被回收，并标记为非活动对象。
    
    GC Root通常包括并不限于以下几种：
    - 全局`windows`对象(位于每个`iframe`中)
    - 文档 DOM 树,由可以通过遍历文档到达所有原生 DOM 节点组成
    - 存放栈上的变量。
2. 回收非活动对象占据的内存
3. 内存整理

代际假说：
- 大部分对象在内存中存在的时间很短，比如说函数内部的变量，或者块级作用域中的变量，当函数或块级代码块执行结束时，作用域内部定义的变量也会被销毁，这一类对象被分配内存后，很快就会变得不可用。
- 只要不死的对象，都会持续很久的存在，比如说 window、DOM、Web API 等。

代际假说将对象大致分为两种，长寿的和短命的，垃圾回收也顺势把堆分为新生代和老生代两块区域。

V8 也分别使用了两个不同的垃圾回收器来高效的实施垃圾回收：
- 副垃圾回收器，主要负责新生代的垃圾回收。**Scavenge 算法**
- 主垃圾回收器，主要负责老生代的垃圾回收。**标记-清除(Mark-Sweep)**

[V8 垃圾回收原来这么简单？ - 知乎](https://zhuanlan.zhihu.com/p/146749402)

### 说下执行上下文、闭包？

闭包：绑定了执行环境的函数。
闭包的组成部分：
- 环境部分
    - 词法环境（所在执行上下文一部分）
    - 标识符列表：函数中用到的未声明的变量
- 表达式部分：函数体

在一个函数的执行上下文中包含若干内容：
- 词法环境。当获取this或变量时使用
- 变量环境。声明变量时使用
- 用于恢复代码执行位置的代码执行状态
- 正在被执行的函数
- 使用的基础库和内置对象实例
- 生成器上下文时表示当前生成器

### 实现一个深拷贝

对于可序列化的对象，可直接使用：`JSON.parse(JSON.stringify(obj))`。但函数、Symbol、HTML Element、递归数据等许多其他情况会失败。☹️

另一种方式，如果在实现了`structuredClone`的JavaScript运行时环境下，可使用：`structuredClone(obj)`

手写深拷贝：
```js
function deepClone (obj, hash = new WeakMap()) {
    if (obj === null) return obj;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    if (typeof obj !== 'object') return obj;
    if (hash.has(obj)) return hash.get(obj);

    let cloneObj = new obj.constructor();
    hash.set(obj, cloneObj);
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloneObj[key] = deepClone(obj[key], hash);
        }
    }
    return cloneObj;
}
```

### JavaScript装箱转换拆箱转换？

每一种基本类型如Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象。

在JavaScript标准中规定了ToPrimitive函数，它是对象类型到基本类型的转换（拆箱转换）
拆箱转换会尝试调用valueOf和toString来获得拆箱后的基本类型。如果valueOf和toString都不存在或未返回基本类型，则会产生类型错误`TypeError`


## Web框架

### Diff DOM

当组件被渲染时，虚拟 DOM 计算新状态和先前状态之间的差异（diffing），并对真实 DOM 进行最小的更改集，以使其与更新的虚拟 DOM 同步（reconciliation）。

**Block Virtual DOM**
1. 静态分析阶段，将树的动态部分提取到 mappings 中（可以在编译时也可以在运行时）;
2. 通过脏检查比较数据来确定发生了哪些变化。状态变化则通过mappings更新DOM（只设计状态而不是虚拟DOM）

具体步骤
- 不使用React渲染jsx，而是使用million.js，用holes 表示动态变化的部分并传递到虚拟DOM，holes作为动态内容的占位符
- 一旦通过脏检查确定状态变化的内容，即可通过mappings找到各自的节点并直接更新DOM
Block Virtual DOM适合的使用场景：
- 静态内容较多。此时可跳过大量静态部分
- 适用于稳定、变化不大的UI树，
