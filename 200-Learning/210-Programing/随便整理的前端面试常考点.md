---
title: "随便整理的前端面试常考点"
description: ""
pubDate: "2023-08-02 09:22"
heroImage: "https://images.unsplash.com/photo-1666278749123-6cc58220fda9?crop=entropy&cs=srgb&fm=jpg&ixid=M3wzNjM5Nzd8MHwxfHJhbmRvbXx8fHx8fHx8fDE2OTA5MzkzNTJ8&ixlib=rb-4.0.3&q=85"
date created: "2023-08-02 09:22"
date modified: "2023-08-02"
draft: true
tags:
    - writings
---

## TOC


## 浏览器

### 聊聊你了解的W3C规范？

W3C相关规范工作组组成：
- **CSS 工作组** 
- **HTML ⼯作组**(HTMLWG) 与**WHATWG**合作发布HTML与DOM正式推荐标准
- **⽆障碍指南⼯作组**发布了WCAG 3.0 ⼯作草案(WD)，除继承WCAG 2.2及以前版本(2.1、2.0)之外，还⾸次纳⼊ UAAG 2.0 (⽤户代理⽆障碍指南) 和ATAG 2.0 (创作⼯具⽆障碍指南) 的内容并进⾏扩展。将提供⼀个新模式来更全 ⾯和灵活地解决 Web ⽆障碍（可访问性）问题
- **Web 性能⼯作组**继续发布性能监测与优化相关的 API
- **Web 应⽤⼯作组**持续客户端应⽤相关技术讨论，Web 在线编辑相关的技术，如⾼亮选择、虚拟键盘、内 容选择等
- **WPT Web平台测试** 规范特性的测试平台

对HTML来说一直都有两个组织维护：HTML工作组（HTMLWG）与WHATWG。是两个独立的组织，不过随着后期的发展，有关于HTML相关的标准都由WHATWG组织维护和推进。

以前描述CSS都是使用版本号来描述，比如CSS1.0、CSS2.0、CSS2.1和CSS3之类，
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230802164441.png)
但随着CSS功能模块变多、每个功能模块发展进度有差异，后面定义CSS规范不再以整体版本号描述，而是按单个模块版本维护，如CSS Grid模块，分为Level1、Level2、Level3之类。

WCAG相关规范构建了具有可访问性Web应用的理论参考和依据。UAAG 2.0 (⽤户代理⽆障碍指南) 和ATAG 2.0 (创作⼯具⽆障碍指南)

[Weixin Official Accounts Platform](https://mp.weixin.qq.com/s/Kq0inC2lrjrvAaP-0ltQoQ)


### DOM树怎么生成的?

一旦浏览器收到第一块数据，它就开始解析收到的信息。“解析”是浏览器将通过网络接收到的数据转换为DOM、CSSOM的步骤，通过渲染器把DOM和CSSOM在屏幕上绘制成页面。

:::info
即使请求的页面HTML超过了14KB，浏览器也将开始解析尝试根据其数据进行渲染。这就是为什么在前14KB中包含浏览器开始渲染页面的所有内容，或至少包含页面模板（第一次渲染所需的CSS和HTML），这对Web性能优化很重要。
:::

渲染DOM树分为5个阶段：
1. 处理HTML标记并构造DOM树。当遇到CSS文件、非阻塞资源（如图片）时解析继续进行，但对于没有`defer`或`async`属性的`<script>`标签时，浏览器会阻塞渲染并停止HTML的解析（虽然浏览器的预加载扫描器会加速该过程）。等待获取CSS不会阻塞HTML解析但会阻塞JavaScript！
2. 处理CSS并构建CSSOM树。CSSOM包含来自用户代理样式表的样式。在此同时，也会有JavaScript编译、构建辅助功能树等过程
3. 将DOM和CSSOM组合为一个Render树。Render树将所有相关样式匹配到DOM树的每个可见节点，并根据CSS级联确定每个节点的计算样式。
4. 在渲染树上运行布局以计算每个节点的几何体。第一次确定节点的大小和位置称为布局，随后对节点和大小的重新计算称为回流。
5. 最后一步将各个节点绘制到屏幕上。绘制可以将布局树上的元素分解为多层，将内容提升到GPU上的层可以提高绘制和重绘性能。当文档中各个不同部分以不同的层绘制相互重叠时，就必须进行合成，以确保按照正确的顺序绘制到屏幕上。

:::note
使用Chrome开发工具进行性能分析分析：
1. Chrome DevTools - more tools - Layers
2. Chrome DevTools - more tools - Rendering
3. Chrome DevTools - more tools - Animations
4. Chrome DevTools - Performance
:::

### script标签中`async`和`defer`属性的区别？

带`async`属性的脚本：
- 对于普通脚本则会并行请求，并加快解析和执行；
- 对于模块脚本，那么脚本及其所有依赖都会在延迟队列中执行，确保它们会被并行请求并尽快解析和执行。

带`defer`属性的脚本：
- 对模块脚本不生效（默认`defer`）
- 对缺少`src`属性的脚本不生效
- 表示在文档解析后，但在触发`DOMContentLoaded`之前执行
- 阻塞`DOMContentLoaded`事件触发，直到脚本完成加载并执行
- 按照文档出现顺序执行

### 讲下浏览器渲染时的合成层？

在每个DOM树节点都会对应一个LayoutObject，当它们的LayoutObject处于相同的坐标空间时，就会形成一个RenderLayers，也就是渲染层。

RenderLayers保证页面以正确的顺序合成，这时候就出现了层的合成（composite），从而正确处理透明元素与重叠元素的显示。

在Chrome中有两种不同的层类型：
- RenderLayer渲染层，负责对应的DOM子树
- GraphicsLayer图形层，负责对应的RenderLayer子树

在RenderLayer下有RenderObject，其保持了树结构并通过向绘图上下文（GraphicsContext）发出绘制调用来绘制Nodes。
每个GraphicsLayer下都有一个GraphicsContext，其用于负责输出该层的位图，位图储存在共享内存中作为纹理上传到GPU中，最后由GPU将多个位图合成，然后draw到屏幕上

:::note
GraphicsContext绘图上下文的责任就是向屏幕进行像素绘制（先把像素级别数据存在位图，然后再显示到显示器），在Chrome里绘图上下文包含了Skia的调用
:::

某些特殊的渲染层会被认为是合成层（Composition Layer），合成层拥有单独的GraphicsContext，而其他非合成层的渲染层，则和第一个拥有GraphicsContext父层共用一个。

影响composite的因素：
- Transform 3D：translate3D，translateZ等
- video、canvas、iframe等元素
- 通过`Element.animate`实现的opacity动画转换
- 通过CSS 动画实现的opacity动画转换
- postion: fixed;
- will-change
- filter
- 有合成层的后代元素同时本身overflow不为visible
- ...

### 回流和重绘的区别？

- Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。
- Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。


### 浏览器缓存？

缓存分为4种，当一次查找且都没命中时，才会请求网络：
- Service Worker + Cache Storage
- Memory Cache。内存使用率比较高的文件。关闭Tab页面就释放
- Disk Cache。 比较大的 JS、CSS 文件会直接被丢进磁盘。
- Push Cache + HTTP2。只在会话存在

通过`HTTP Header`设置缓存策略：
1. 强缓存
    使用强缓存不会发送HTTP请求，直接从缓存中拿数据，状态码为200，size显示为`from disk cache`或`from memory cache`。
    强缓存可以通过设置两种 HTTP Header 实现：`Expires` （服务器事件和浏览器事件可能不一致）和 `Cache-Control`。
2. 协商缓存。
    强缓存失效就进入协商缓存。
    浏览器在请求头中携带缓存标识，服务器根据缓存标识决定是否使用缓存，协商缓存生效则返回 304 和 Not Modified，失效则返回 200 和请求结果。
    协商缓存可以可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag`。

:::warning
**如果什么缓存策略都没设置**：浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。
:::


### 什么是`process-per-site-instance`策略？

每个标签对应一个渲染进程，如果从一个页面打开了一个新页面，新打开的页面与当前页面还属于同一个站点的话，那么新页面会复用当前页面的渲染进程。

### 能说在什么是核心网页指标Core Web Vitals吗？



## HTTP

### DNS解析流程？

![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230804140218.png)

- 根 DNS 服务器：返回顶级域 DNS 服务器的 IP 地址
- 顶级 DNS 服务器：返回权威 DNS 服务器的 IP 地址
- 权威 DNS 服务器：返回相应主机的 IP 地址


## JavaScript

### 说说你知道的JavaScript解释器？

JIT(Just-in-time) compilation engines：
- v8。Google Chrome
- Chakra。Edge(Internet Explore)
- Spider Monkey。Mozilla FireFox
- JavaScript Core Webkit。Safari
- Hermes。Meta React Native

Runtime interpreter engines：
- QuickJS
- Boa。Written in Rust
- Rhino。Mozilla

### 聊聊你了解的V8垃圾回收

#### 调用栈的垃圾回收

有一个记录当前执行状态的指针(称为 ESP)指向调用栈中的函数执行上下文。当函数执行完成之后，就需要销毁函数的执行上下文了，这时候，ESP 就帮上忙了，JavaScript 会将 ESP 下移到后面的函数执行上下文，这个下移的过程就是销毁当前函数执行上下文的过程。

#### 堆中的垃圾回收

与栈中的垃圾回收不同的是，栈中无效的内存会被直接覆盖掉，而堆中的垃圾回收需要使用 JavaScript 中的垃圾回收器。

垃圾回收一般分为下面的几个步骤：
1. 通过 GC Root 标记空间中的**活动对象**和**非活动对象**
    目前 V8 采用 可访问性(reachablility)算法来判断堆中的对象是否为活动对象。这个算法其实就将一些 GC Root 作为初始存活对象的集合，从 GC Root 对象触发，遍历 GC Root 中的所有对象。
    1. 能够通过 GC Root 遍历到的对象会被认为**是可访问的**，我们将其标记为活动对象，必须保留
    2. 如果一个对象无法通过 GC Root 遍历到，那么就认为这个对象是**不可访问的**，可能需要被回收，并标记为非活动对象。
    
    GC Root通常包括并不限于以下几种：
    - 全局`windows`对象(位于每个`iframe`中)
    - 文档 DOM 树,由可以通过遍历文档到达所有原生 DOM 节点组成
    - 存放栈上的变量。
2. 回收非活动对象占据的内存
3. 内存整理

代际假说：
- 大部分对象在内存中存在的时间很短，比如说函数内部的变量，或者块级作用域中的变量，当函数或块级代码块执行结束时，作用域内部定义的变量也会被销毁，这一类对象被分配内存后，很快就会变得不可用。
- 只要不死的对象，都会持续很久的存在，比如说 window、DOM、Web API 等。

代际假说将对象大致分为两种，长寿的和短命的，垃圾回收也顺势把堆分为新生代和老生代两块区域。

V8 也分别使用了两个不同的垃圾回收器来高效的实施垃圾回收：
- 副垃圾回收器，主要负责新生代的垃圾回收。**Scavenge 算法**
- 主垃圾回收器，主要负责老生代的垃圾回收。**标记-清除(Mark-Sweep)**

[V8 垃圾回收原来这么简单？ - 知乎](https://zhuanlan.zhihu.com/p/146749402)

#### 新生区如何晋升为老生区？ 

1. 一些大的对象会被直接分配到老生区 
2. 在新生区经历两次垃圾回收还能存活，会被晋升

#### 全停顿

垃圾回收操作会暂停 JavaScript 的运行，回收完毕后才会恢复执行，这种行为就是全停顿。 

为了降低全停顿所带来的卡顿，V8 引擎采用了增量标记(Incremental Marking) 算法进行优化，将标记过程分为一个个小任务，这些小任务的执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样就不会有明显的卡顿了。 

当然，V8 所采用的优化方案不只这一种，而是多种方案综合使用的，除了增量回收还有并行回收、并发回收等。 
- 并行回收：垃圾回收器会使用多个辅助线程来并行执行垃圾回收 
- 并发回收：回收线程在执行 JavaScript 的过程中，辅助线程在后台执行垃圾回收


### 说下执行上下文、闭包？

闭包：绑定了执行环境的函数。
闭包的组成部分：
- 环境部分
    - 词法环境（所在执行上下文一部分）
    - 标识符列表：函数中用到的未声明的变量
- 表达式部分：函数体

在一个函数的执行上下文中包含若干内容：
- 词法环境。当获取this或变量时使用
- 变量环境。声明变量时使用
- 用于恢复代码执行位置的代码执行状态
- 正在被执行的函数
- 使用的基础库和内置对象实例
- 生成器上下文时表示当前生成器

### 实现一个深拷贝

对于可序列化的对象，可直接使用：`JSON.parse(JSON.stringify(obj))`。但函数、Symbol、HTML Element、递归数据等许多其他情况会失败。☹️

另一种方式，如果在实现了`structuredClone`的JavaScript运行时环境下，可使用：`structuredClone(obj)`

手写深拷贝：
```js
function deepClone (obj, hash = new WeakMap()) {
    if (obj === null) return obj;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    if (typeof obj !== 'object') return obj;
    if (hash.has(obj)) return hash.get(obj);

    let cloneObj = new obj.constructor();
    hash.set(obj, cloneObj);
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloneObj[key] = deepClone(obj[key], hash);
        }
    }
    return cloneObj;
}
```

### JavaScript装箱转换拆箱转换？

每一种基本类型如Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象。

在JavaScript标准中规定了ToPrimitive函数，它是对象类型到基本类型的转换（拆箱转换）
拆箱转换会尝试调用valueOf和toString来获得拆箱后的基本类型。如果valueOf和toString都不存在或未返回基本类型，则会产生类型错误`TypeError`


### 能说下前端的模块系统吗？

#### AMD与CMD的区别？

- 对于依赖的模块，AMD提前执行，CMD是延迟执行
- CMD推崇依赖就近，AMD推崇依赖前置
- AMD的API一个能当多个用，职责单一；CMD每个API都简单纯粹

UMD是AMD和CommonJS的综合产物，AMD用于浏览器，CommonJS用于服务器。UMD则是则是两者的兼容模式，解决了跨平台问题。

#### CommonJS的实现原理？

在编译过程中，对CommonJS模块代码进行包装放到一个函数中，并将require、exports、module作为形参传入进去。
在模块加载的时候，通过类似eval的函数执行模块包装函数。

#### ES Module与CommonJS的差异？

1. 语法 `import/export` `require/module`
2. ESM静态导入导出，编译过程确定了模块依赖路径，易实现tree shaking；import() 懒加载、代码分割；
3. CommonJS同步加载并执行文件；ESM提前加载并执行文件
4. CommonJS由JS运行时实现；ESM是语言特性支持
5. ESM模块导出的值是动态的，CommonJS导出值是原始值的副本。



## Web框架

### Diff DOM

当组件被渲染时，虚拟 DOM 计算新状态和先前状态之间的差异（diffing），并对真实 DOM 进行最小的更改集，以使其与更新的虚拟 DOM 同步（reconciliation）。

**Block Virtual DOM**
1. 静态分析阶段，将树的动态部分提取到 mappings 中（可以在编译时也可以在运行时）;
2. 通过脏检查比较数据来确定发生了哪些变化。状态变化则通过mappings更新DOM（只设计状态而不是虚拟DOM）

具体步骤
- 不使用React渲染jsx，而是使用million.js，用holes 表示动态变化的部分并传递到虚拟DOM，holes作为动态内容的占位符
- 一旦通过脏检查确定状态变化的内容，即可通过mappings找到各自的节点并直接更新DOM
Block Virtual DOM适合的使用场景：
- 静态内容较多。此时可跳过大量静态部分
- 适用于稳定、变化不大的UI树，

### Vue

#### 谈谈你对MVVM的理解？

MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种设计思想。 Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑; View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，View 是一个同步 View 和 Model 的对象 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互， Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。 对 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的 同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

#### Vue的响应式系统如何创建的？

Vue的响应性系统是通过深度转换JavaScript对象为响应式代理来实现的。通过Proxy追踪对象的读写操作。

在track内部，检查当前正在运行的副作用，被将副作用存储在一个全局的WeakMap数据结构中。
在trigger中，查好该属性所有的副作用订阅，并执行它们。

在响应式副作用中，更新视图（调用虚拟DOM渲染函数）。

#### Vue为何跟推荐使用模板而非渲染函数？

Vue 模板会被预编译成虚拟 DOM 渲染函数。Vue 也提供了 API 使我们可以不使用模板编译，直接手写渲染函数。在处理高度动态的逻辑时，渲染函数相比于模板更加灵活，因为你可以完全地使用 JavaScript 来构造你想要的 vnode。

那么为什么 Vue 默认推荐使用模板呢？有以下几点原因：
1. 模板更贴近实际的 HTML。这使得我们能够更方便地重用一些已有的 HTML 代码片段，能够带来更好的可访问性体验、能更方便地使用 CSS 应用样式，并且更容易使设计师理解和修改。
2. 由于其确定的语法，更容易对模板做静态分析。这使得 Vue 的模板编译器能够应用许多编译时优化来提升虚拟 DOM 的性能表现。

编译器可以静态分析模板并在生成的代码中留下标记，使得运行时尽可能地走捷径。与此同时，Vue仍旧保留了边界情况时用户想要使用底层渲染函数的能力。称这种混合解决方案为**带编译时信息的虚拟 DOM**。

提升运行时性能的手段：
1. 静态提升。复用、压缩静态内容
2. 编译时保留更新类型标记。使用位掩码技术更新和检查：元素所需的更新类型、vnode子节点类型
3. 树结构拍平。将结构稳定的部分编译为一个拍平的数据，减少虚拟DOM协调时需要遍历的节点数量，任何静态部分都会被略过。

#### Vue3组合式API的优势有哪些？

1. 更好的逻辑复用
2. 更灵活的代码组织
3. 更好的类型推导
4. 更小的生产包体积

#### Vue的生命周期？

![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230802160714.png)

#### Vue2和Vue3 Diff算法分别说一下？

简单来说，diff 算法有以下过程
- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心 diff)
- 递归比较子节点

**Vue2 的核心 Diff 算法采用了双端比较的算法**。同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

**Vue3.x 借鉴了 ivi 算法和 inferno 算法**。在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。

#### 解释一下 vue-router 的完整的导航解析流程是什么？

一次完整的导航解析流程如下：
- 1.导航被触发。
- 2.在失活的组件里调用离开守卫。
- 3.调用全局的 beforeEach 守卫。
- 4.在重用的组件里调用 beforeRouteUpdate 守卫（2.2+）。
- 5.在路由配置里调用 beforeEnter。
- 6.解析异步路由组件。
- 7.在被激活的组件里调用 beforeRouteEnter。
- 8.调用全局的 beforeResolve 守卫（2.5+）。
- 9.导航被确认。
- 10.调用全局的 afterEach 钩子。
- 11.触发 DOM 更新。
- 12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

#### keep-alive 实现原理？

在具体的实现上，keep-alive 在内部维护了一个 key 数组和一个缓存对象。
key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值

cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM

在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。

当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素。

### Svelte


### React

#### 什么是forward refs？

`forwardRef`将组件的DOM节点通过`ref`的方式暴露给父组件

```jsx
const ButtonElement = React.forwardRef((props, ref) => (
    <button ref={ref} className="CustomButton">
        {props.children}
    </button>
));

// Create ref to the DOM button:
const ref = React.createRef();
<ButtonElement ref={ref}>{'Forward Ref'}</ButtonElement>
```


## HTML

### `src`和`href`的区别？

首先需要了解一个概念：替换型元素。常见的替换型元素有：script、img、video、audio、iframe

:::tips
替换型元素是把文件内容引入，替换掉自身位置的一类标签🏷️。
:::

**凡是替换型元素，都是用src属性引用文件，链接型元素使用href属性。**

这也就解释了，为何style标签不能使用src，只能使用link+href引入样式的问题了🙋

### DTD是什么？

DTD全称是Document Type Definition，也就是文档类型定义。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

SGML（Standard generalized markup language）用DTD定义每一种文档类型，HTML属于SGML，在HTML5之前，HTML都是使用符合SGML规定的DTD。但这些复杂的DTD写法并没有实际作用（浏览器并不会用SGML引擎解析它们），因此到了HTML5干脆放弃了SGML子集的坚持，规定了简单易记的DTD：
```html
<!DOCTYPE html>
```

### 如何实现给图片设置部分区域可点击？

`usemap`属性+`<map>`
[HTMLImageElement: useMap property - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/useMap)

### 什么是OGP？有何作用？

OGP全称Open Graph protocol，Facebook在2010年推出的一组网页元信息标记协议，是一组为社交分享而生的Meta标签。

如果网页采用OG协议，分享结果会在支持OG协议的网站进行结构化展示，这样站点在被链接分享时会有更丰富的内容展示。
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230802170307.png)

设置方法很简单，只需要在header内添加几个meta标签即可：
```html
<meta property="og:title" content="显示的标题" />  
<meta property="og:type" content="对象类型" />  
<meta property="og:url" content="分享的url地址" />  
<meta property="og:image" content="缩略图地址" />  
<meta property="og:description" content="显示的描述信息" />  
<meta property="og:site_name" content="网站名称" />
```

更多的属性设置，参考官网：[The Open Graph protocol](https://ogp.me/)

以OG官网为例，其设置如下：
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230802170533.png)

在 facebook，twitter 等网站，有分享卡片检测工具，可利用这些工具，检测分享设置是否成功。
- twitter 分享检测: https://cards-dev.twitter.com/validator
- facebook 分享检测: https://developers.facebook.com/tools/debug/sharing/
- linkedin 分享检测: https://www.linkedin.com/post-inspector/inspect/

## JavaScript

### === 与Object.is的区别？

Object.is 方法是 _ES6_ 新增的用来比较两个值是否严格相等的方法，与 === (严格相等)的行为基本一致。不过有两处不同：

- +0 不等于 -0。
- _NaN_ 等于自身。

所以可以将Object.is 方法看作是加强版的严格相等。

