---
title: "《程序人生》"
description: ""
pubDate: "2023-08-14 13:26"
heroImage: "https://images.unsplash.com/photo-1535551951406-a19828b0a76b?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1200&q=80"
date created: "2023-08-14 13:26"
date modified: "2023-08-14"
tags:
    - notes
    - Programming
---

> 生命不在于你活了多少日子，而是你记住了多少日子。

## TOC

## 两万字长文：聊聊程序人生

[https://mp.weixin.qq.com/s/Ctc_Gs65Q0_ekqdikP45lw](https://mp.weixin.qq.com/s/Ctc_Gs65Q0_ekqdikP45lw)

### 我想独立完成一个产品，技术上该怎么提升？

1. 对自己的定位。个人独立完成，还是只是前端工程师、后端工程师
2. 要带着问题去学习
   - 发现缺失的很多知识点，怎么弥补？
   - 开发中使用什么架构？
   - 前端开发领域如何做技术选型？
   - 后端技术栈如何抉择？
   - ...
3. 吸收和消化为了解决具体问题而寻找的助力，内化成自己的东西
   边做边学，边做边探索，然后总结，内化

### 怎么找到好玩的项目？

- 涉及到信息来源的问题
- 逛个两三次 hacker news 和 Github trending（or followers's stars）、看一看各个开发者聚集的地方如Reddit相关主题贴、一些公众号

### 看过的或者学过的技术，如何在需要的时候找回来？

在开始看某个东西时，如果觉得未来在某个场景下会去使用它，会在笔记的对应的主题下面

比如说我在 Github 上 Star 了很多很有意思的做搜索的项目，比如说现在在 Rust 上面比较火的一个叫 meilisearch，一个叫 Sonic，这些东西我现在并不需要，所以我现在可能不见得会用到他们，但是我会放在搜索的主题下面，下次我要深入了解探索这个方向的时候，那么可能会深入探索。

不光是 Github repo，还有我在 Youtube 和 B 站上看过的视频，我都会放在专门的页面里面，做成 database。

如果多少年之后成为一个什么样的人，比如架构师，那么其实你需要做的就是你平时对你所用的东西，你感兴趣的东西，保持一份好奇心：你看到一个一个产品，就要去想这个产品背后的逻辑是什么，它的功能是怎么样实现的。如果我自己要实现的话， 这一块功能，那块功能我该用什么样的工具实现，我是自己实现，还是我拿第三方工具，我有哪些工具可以使用。这样你就可以把平日里看到的东西和你的思路串联起来。

你可以顺便多想一些，比如：如果真得要实现的话，实现到一个什么样的程度，大概花多少钱？这些东西我觉得可以反复可以在自己的脑海里面去探索，你不一定去做，因为很多时候我们遇到的东西太多了，真正值得你去深入下面去做的，一年可能也就是两三个，因为你的时间精力毕竟有限。

大部分的时候你即便不做，你可以去想，因为想本身想的过程就本身已经足够好了，因为你在思考的时候你会你会遇到问题，这个问题即便你不是去写代码解决，你也可以通过去搜索，你可以去看看别人是别人的解决方案是什么，甚至你可以对这个产品本身做 reverse engineering，去验证你的想法和人家做的是不是一样。

这些东西其实都是你在思考，你在使用 reverse engineering 的时候，你会发现这是一个问题，他没有解决好。那我该怎么样解决呢？我的方法是不是好，如果好为什么好，如果不好的话，还有什么更好的解决办法等等。这个循环往复的过程会让你的进步会很快，很多人说我在大公司里面或者在公司里面，我作为一个程序员就是一颗螺丝钉，每天能接触的事情就那么一点，那是因为很多时候有一个更广阔的世界我们可能还没有去发现。

### 如何定义搬砖？如何形成反搬砖的文化？

搬砖与否，因为其实我觉得很多公司的，程序员都会有这样的感慨，就是我的工作好像就是在搬砖，我的工作好像就是在被动处理产品经理的想法，他们不管最终这个产品本身会给技术带来多少的技术债，都要求必须要在规定的时间，以规定的方式来完成，这就会让大家产生一种搬砖的无力感。我觉得这是很多公司在文化上面形成的一种氛围，很多时候需要靠时间来慢慢去把它改变。

第一个对我们所做的事情，不光知其然，还知其所以然。
>希望我们招的工程师，或者说我们的工程师本身要有极大的热情，想成为一个非常牛逼的工程师。怎么叫牛逼的工程师，我觉得这可能也是我们每一个技术人应该去追寻的方向，

第二个就是你要对你所做的，领域产品有强烈的主人翁的意识，ownership，就说这个东西好像就像我的孩子一样，我不知道大家有多少有孩子，你对你的孩子付出的努力跟对，别人家的孩子付出的努力，那是完全不是一个概念的。

第三个就是你的方案，你提出来的方案一定是要能够，落地，能够交付的这样一个解决方案，不是天马行空的画一个大的 picture，画一个非常酷的 architect，最后谁落地，反正我就提方案你们来落地，我们不需要这样的人。

第四个就是你要对产品中的槽点要零容忍，你的产品经理提出来的一些不合理的产品的需求，你要能给他打回去，你如果打不回去，你要能让你的经理去打回去。当然你要有充足的理由，充足的数据来说明这个事情不对。

第五个就是你对重复的任务和bug是一种零容忍的态度，我们工程师为什么会产生一种搬砖的感觉，除了刚才讲的产品上面你有很多问题，你无力去打破，还有一个在工作中我们可能有太多不停重复的任务，因为产品的需求截止日期太严苛，导致于我们只能着眼于以现在，没办法着眼于未来，没办法把这个东西抽象在一个更高的层次上面去抽象，把它做成某一个service，或者做成一个就是能涵盖包含了这个场景下面一系列场景的解决方案。

第六点是：当你成为某个领域的专家之后，你应该还是保持一个非常开放的心态，随时愿意切换你的技术栈和方法论。你不会去抗拒任何不同的思想。比如说我是一个函数式编程的粉丝，我就鄙视一切面向过程编程的所有的方法论；我是一个 react 的开发者，我就对 vue 充满了不屑和鄙视，认为它是初级程序员的专利，是那些理解不了 react 的人才会写的东西。我觉得我们程序员不应该有这样的心态，我们还是要像小王子里面说的那样，像一个小孩子一样，对什么东西都保持天然的好奇心，愿意把自己的那些「星星」都放到天空中，而不是把它包裹起来藏得很深。所以有必要的话你应该愿意去切换技术栈，切换方法论，有更好的方法，你会愿意去尝试，你会愿意去用数据来说服自己和别人：这个东西值得我们去去投入。

最后一点是你要总是能够让你的团队变得更强。你自己强还不够，你怎么样能用你自己的强大，你的影响力，无论是技术的影响力还是其他方面的影响力，让你周围的人变得更强。

工程师需要足够的时间去内化他所学的东西，去深度地考虑产品，在无数个可能的解决方案中去寻找潜在的最好的方案。

所以这是一个悖论，就是产品的需求，我明天后天下周我就要这么个东西，而很多时候不是你给我一个固定的时间，我就能把这个事情完成的。而且一旦你给了我一个固定的时间，我能采用的方案，大概率是众多的方案中不那么好的，或者说仅仅是为了解决问题而解决问题的方案。在这种时间的压力下，会导致工程师没有安全感，因为我没有时间去充分思考，我没有时间去探索，产品中有无数的bug，我没有时间去处理，我没有时间去追根跑底，我只能去一个的想办法把它绕过它，找一个「快而脏」，而不是一个终极的解决办法去敷衍。所以这需要时间，需要给工程师一个足够足够长的时间去来出来消化这个东西，让工程师足够有足够的权威，能够 push back，说这个东西我觉得不合理，你产品还没想清楚，你想清楚了之后在跟我谈，为什么我说你没想清楚，因为 case1，case2，case3 等等这些东西你没有考虑到，这些场景下我们该怎么样去处理，你没有想，所以这个东西我不能做。这是很多国内的公司还缺乏的一种文化：就是工程师来能够对产品说 NO。因为不能说 NO，所以 996甚至 007 也要把它弄完。这其实是一个是一个很折磨人的过程，这对我们工程师来讲，成长是不利的；长远来讲，短期公司得到的一些利益，长远可能也不见得那么有利。

### 如何处理有限的资源和产品质量之间的冲突？

大部分的决策我们要去去讨论的，是 why，为什么我们要做这件事情，这件事情做出来之后对我们的好处是什么，很多时候公司的 CEO 也会拍脑门做一些决定，不见得 CEO 做的决定都是对的，有可能其中 40% 能被我们挡掉，但剩下的60%，无论如何是不得不做的，并且它是有一些截止日期的压力，比如说你要为了某个事件，在这个事件之前，我必须要做出来某个产品的 feature，甚至某个产品来应对这个事件，因为我知道这样的时机一旦错过，可能下一个几年才能遇到的东西。这个时候我们如果说商业决策想清楚了，ROI 都算好了，那就是一个调动资源的问题，这个东西我们要评估它的 scope 有多大，有多少资源可以去使用，我们愿意为它付出多少代价，这个代价不光是内部的，还有外部的。如果自己做受限于资源无法做到更加稳定，那么可不可以找付费的供应商去做？

我觉得是当我们有一些截止日期不得不去满足的时候，我们从工程师从 CTO 或者技术骨干的角度，我们需要去考虑：有些东西我们是不是这个时刻必须要自研？就像clubhouse这样，我的核心的功能是什么，我怎么样去调配我的核心资源去做我的核心功能，把不那么核心的功能，我如果能多花一些钱就能解决的，是不是可以先把它在这个时刻用第三方服务解决？因为所有技术我一起上的话，以我现在的资源就是满足不了这个日程。所以这是一个博弈的过程，你需要跟做商业决策的那些stakeholder，比如说CEO要去博弈这些东西，你可以提出一些技术的解决方案，你说 ok 为了做这么一个东西，我需要用这些第三方服务，这些服务如果用户量级在这个程度下一个月的cost是多少。我把这个东西列出来，如果 CEO 不同意，那么我们需要这么多资源，并且我没办法保证能在日程截止之前我能完成这样的东西。这就是一个博弈的过程，需要讨价还价。不是说什么东西，别人说 ok 我就要做，我就让我手下的这兄弟们拼命地加班，没日没夜的去做这个东西。这样子长久不了，可能还会带来很多的技术债。

:::tldr
向上管理
:::

### 团队做大，人才密度是肯定下降的，不能要求人人都有主人翁的心，能不能用精细的流程来避免搬砖？

我觉得讨论就是大家和而不同，我赞同你里面的很多观点，也不赞同里面的一些观点，比如说我赞同人才密度降低这件事情，就是当你公司做大人才密度肯定，是以指数级下降，很难去避免。怎么样去尽量让下降的速度慢一些呢？我觉得一个很好的方式是通过文化来保证，你怎么样通过同一种文化的感召力去召唤那些认同你的文化的人进入到你的公司。这里相关的东西我就不展开来谈了。我稍微不太认同的是过于严谨的规则。每个公司都有一堆的规章制度，有一堆的流程，这无可厚非。

流程应该是能被自动化的东西，它不需要你去学习和遵循，工具本身就帮助你准守流程了。

比如说当你的代码提交之后，有一堆的 pre commit check，要去check你的代码风格对不对，你是不是过了静态检查，是不是过了单元测试，所有这些都通过后才会允许你提交代码。你 push 上去的时候会有一堆的 github action 去执行，去从各个维度去看你这个代码，是不是符合足够质量的，是不是破坏了现有的 code coverage 等等。这些东西不应该是写成文字去，让每个工程师去遵守的，而是就在你的工具链里，在你的公司的日常运作的过程中，自然而然地去使用规则和流程约束每个工程师的行为。而且越好的团队你会发现自动化的流程越多，就像我们写代码一样，框架是干什么的，框架就是一堆东西来限制开发者的行为，让我们有所为有所不为。为什么我们要做信息隐藏，为什么我们要去做各种各样的解耦，为什么我们要去使用各种各样的设计模式，这些其实都是流程，这些流程都是刻在我们平时开发者骨子里的流程。我觉得这些自然而然发生的流程，是最好的流程。

从另外一个角度来讲，我觉得真正的人才，如果真的把程序员看做艺术家的话，我们很难用规则去来框定它，就像截止日期件事情，如果说你毕加索在 10 天之内画出来某幅指定要求的画，那么毕加索可能画出来的，就跟我们普通的一个画师画出来的是一样的东西。梭罗在瓦尔登湖里面，讲过一句话，我特别喜欢，他说：能维持一只兔子生活的田野一定是贫瘠无比的，我觉得好的公司它就是好的公司，不好的公司它就是不好的公司，很多公司大了之后，它可能只是比小的时候没有那么，好而已，但它依旧是好的公司，好的公司很多公司它很小的时候，就跟上可能不是一个好的公司，它大了之后也一定不会是一个好的公司。


## 客户端软件的轮回：更好还是更糟糕？

对 SaaS 软件的愿景
- 客户端软件可以真正做到数据的 local first，云端的数据更像是一个数据的超集或者备份。
- 当数据 local first 后，对数据的各种操作（聚合，过滤，查询等）都可以利用本地 CPU 的强悍性能直接处理，而无需跨过网络。
- 协同工作，对公司（组织，团队等）内部的人员来说，由权限系统以及要同时处理某一个文档或者数据的 N 个人（设备）之间的可信共识（比如 raft concensus）处理即可 —— 这应该是绝大多数的使用场景；如果参与者不可信，可以考虑使用不可信共识（比如 BFT consensus）。
- 如果能进一步，刨除服务器（或者服务器仅仅做备份的功用），完全去中心化，那将更加美妙，不过在资本市场这个故事很难讲好（需要新的估值模型）。


## 想象力，工程方法以及取舍

[https://mp.weixin.qq.com/s/3OlEBl9ybiNQ2s328DVCEQ](https://mp.weixin.qq.com/s/3OlEBl9ybiNQ2s328DVCEQ)

### 如何保证 single source of truth（以下简称 SST）?
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230814140759.png)
在分布式系统里，能被正确用作 SST 的只有事件（event，或者 operation）。从整个应用的角度，主流的思想是把广义的数据库（RDBMS，DDBMS，kv store，object store）作为 SST，这无可厚非，但我们不能因此推断出数据库就等同于 SST，或者得出结论没有数据库就没有 SST。从数据库的角度看，数据库里存储的数据（状态）并不是 SST，数据库的 SST 是一个个的 op —— 你可以理解为增删改的动作 —— 它们就是一个个事件。这是最原始，也最容易在集群中复制的信息，数据库的状态可以通过这些 oplog/WAL 按顺序迭加恢复出来。

在 web app 里，我们在更高的层次实现业务逻辑，因此可以把数据库里的数据（状态）作为 SST。因为我们知道，不管数据库的实现是强一致性，还是弱一致性，它们都能保证最终一致性（当更新停止时，最终所有的数据库节点都能聚合到同样的数据）。而保证了最终一致性的数据库，就有资格被当做 SST。

当我们把数据下放到每个客户端时，每个客户端其实可以被看做所有客户端维护的数据库系统的一个节点。上图中一个个 list，就是状态。我们的目标是这些状态的最终一致性。而根据数据库的思路，SST 是事件 —— 用户对 list 的各种操作。这些事件主要有：
- 在 list 里添加一个新的数据项
- 修改一个已有的数据项
- 删除一个已有的数据项
- 移动一个已有的数据项

我们如果能在所有参与的节点中确保所有的事件都被正确扩散，那么，通过迭加这些事件，我们可以得到最终一致的状态。

### 通过迭加这些事件，得到最终一致的状态?

「不可能先生」的头几个质疑：
1. 网络不稳定，事件有可能丢；
2. 事件到达不同客户端的顺序可能不一致。

假设我们有办法做到不丢事件，并且保持同样的事件顺序。所有的客户端的状态都可以被描述成（S 代表状态，E 代表事件，+ 代表事件叠加）：
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230814141201.png)

不丢事件如何保证？
- 如果用中心化的解决方法，可以引入一个 message queue（其实变相引入了 raft 这类 CFT 共识算法）
- 如果去中心化的解决方案，需要引入类似区块链技术使用的共识机制来确保顺序（区块链的区块，实质上是一个全局时钟，它用来提供一致的事件顺序

要求所有的客户端都看到顺序一致的事件？
- 事件到了服务器之后被排序，客户端需要按照服务器要求的顺序生成状态。
  不仅仅要支持迭加的操作（+），还需要支持回滚（-）
产生了新的问题🙋，如何解决冲突？先按下不表

![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230814141801.png)

如何确保不同客户端看到的数据一致？
1. list 里所有数据都有全局唯一的 id。这里我们用 task1, task2, ...。数据的 id 中包含客户端的 id。
2. 每个数据有一个指针，指向前一个数据，以便于我们定位其相对位置，移动数据的时候，我们需要更新这个指针来保持数据的相对位置。
3. id 之间是可以比较的，比如上图 A 和 B 都在 task5 之后插入了一个新的 item，我们定义 b6 > a6 的比较关系（这个无所谓，也可以 a6 > b6），这样，task_b6 的前一个数据是 task5，而 task_a6 的前一个数据 task_b6。

### 如何解决冲突？

幸运的是，目前已经有很多已知的算法来解决在线协作的问题。其中典型的两种算法是 OT（Operational Transformation）和 CRDT（Conflict-free Replicated Data Types）。

#### OT

OT 是一个思路简单，但实现复杂的算法，其基本思想是，不同的节点在收到不同顺序的事件（在 OT 下是 operation）时，将后续的 OP 进行 transform，使其能够分别聚合出相同的状态，如下图：
![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230814142057.png)
那么谁来做这个 transformation 呢？服务器。Peer1 和 peer2 在执行了自己的操作 OP1 和 OP2 后，将操作通过服务器发送给对端，服务器根据收到的 OP，可以确定一个唯一的顺序，也就是能够确定一个唯一的最终状态，然后服务器再根据每个客户端的不同情况，对将要转发给客户端的 OP（对于 pper1 是 OP2，对于 peer2 是 OP1）进行相应的 transformation，然后发送之。这样，客户端在接收到修改后的 OP 后，可以生成和服务器一致的状态。

#### CRDT

如果说 OT 是一个中心化的解决方案，那么 CRDT 则是一个非中心化的解决方案。

- [GitHub - automerge/automerge: A JSON-like data structure (a CRDT) that can be modified concurrently by different users, and merged again automatically.](https://github.com/automerge/automerge)
- [GitHub - y-crdt/y-crdt: Rust port of Yjs](https://github.com/y-crdt/y-crdt)
- [GitHub - yjs/yjs: Shared data types for building collaborative software](https://github.com/yjs/yjs)
- [How CRDTs make multiplayer text editing part of Zed's DNA](https://zed.dev/blog/crdts)

### 继续放飞想象力

我们还以 Notion 为例。一个 Notion 用户可以有多个 workspace。如果数据全部放在本地，以 CRDT 的形式保存成文件，那么一个 workspace 在本地可以存储在一个目录下。根目录下可以存放这个 workspace 下所有用户的基本信息，用一个 automerge 下的 table（姑且简称 amt），存为 user.amt。这个文件里的用户信息，当前用户只能修改自己那一行；workspace 的 owner / admin 可以增删改。用户信息之外，我们还需要一个 permission.amt，存储每个用户在不同上下文下的角色。这样，我们可以使用 oso[7]，通过 RABC 来处理授权。user/permission 相当于 workspace 的 metadata，其它的 metadata（比如配置）我们放下不表。

workspace 承载的是用户的数据。对于目录树，我们可以用一个 workspace.amt 来保存目录树的 CRDT 数据。目录树下有子目录或文件，子目录下有更深的目录或者文件。和文件系统的目录树类似，这里的文件我们放一个引用，然后文件本身有单独的 amt，如 doc4.amt。整个 workspace 的结构如下：

![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230814142643.png)

当用户在 UI 上对某个文档做了一个改动后，这个改动的 `change` 会从前端界面发送到应用的后端（非服务器的后端）。在应用的后端，automerge backend 对改动进行处理后，会生成一个 patch，提交回 frontend 去 `apply`。同时，这个改动通过网络（可以是服务器中转，也可以是 p2p 网络）传播出去。比如我们可以使用 libp2p 下的 gossipsub，在某个 topic 下传播。topic 可以是某一个 workspace，只有在这个 workspace 下的用户才能加入到这个 topic 下。当客户端 B 收到这个 `syncMessage` 后，它会提交给 automerge backend，生成 patch，提交给 frontend `apply`。

![image.png](https://raw.githubusercontent.com/fw6/assets/main/toy_docs/20230814142732.png)

如果整个系统中有服务器中转事件，那么服务器可以 tap 出一份 amt 作为备份。一个新加入的客户端可以迅速从服务器拿到整个历史记录，进而参与到 workspace 的协作中。如果整个系统中没有服务器中转事件，使用的是 p2p 网络，那么服务器可以充当 p2p 网络中的一个节点，tap 出 amt 做备份。新加入的客户端节点可以从其任一个邻居那里要完整的数据。

### 取舍（Trade off）

CRDT的好处：
- - local first：数据存储到本地，即时的响应速度，允许离线处理。
- 可以不依赖服务器而在客户端提供各种各样的数据访问的方式（filter, aggregate, projection, gorupby 等等），甚至，可以提供 API 让本地数据很容易被 pandas 等工具使用。
- 即便使用服务器中转，其服务器资源的开销相对要小很多，对于一个大型的项目，节省的资金会很可观。

缺点：
- 随着时间本地数据会增长得越来越大，由于存储着数据的全集，这个数量可能会很可观（可以有一些优化，比如用户上传的图片，视频这样的静态资源可以放在 S3，本地只放链接，访问时再获取 presigned url），所以，这种方法很可能**不适合在浏览器端使用**。
- 整个系统的复杂度比大家熟悉的 web 技术栈要大很多。
- 技术栈小众，很难找到合适的工程师（当然，这也意味着一旦找到，必然是优秀的工程师）。
- 市场上缺乏成功的先例（我指专门处理列表和文档这块的 sequence CRDT，其实 CRDT 在很多软件中已经得到了广泛使用，比如 phoenix framework，redis 等）。

